#!/usr/bin/env python3

import sys
import re
import signal

# Handle broken pipe gracefully
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

def print_usage(script_name):
    print(f"Usage: {script_name} [filename] [width]")
    print(f"Examples:")
    print(f"  {script_name}               Read from stdin, width=60")
    print(f"  {script_name} bible.txt     Read from file,  width=60")
    print(f"  {script_name} bible.txt 70  Read from file,  width=70")
    print(f"  {script_name} 70            Read from stdin, width=70")
    print(f"  {script_name} -             Read from stdin, width=60")
    print(f"  {script_name} - 70          Read from stdin, width=70")

def justify_text(file_input, width=60):
    # Read all lines first to check context
    if hasattr(file_input, 'read'):
        # It's a file object (stdin or opened file)
        lines = [line.rstrip() for line in file_input]
    else:
        # It's a list of lines
        lines = file_input

    total_lines = len(lines)

    for i, line in enumerate(lines):
        if not line:
            print()
            continue

        # Check if this line is a book title
        # Book titles are followed by an empty line and then a chapter title
        prev_empty = (i == 0) or (i > 0 and not lines[i-1].strip())
        next_empty = (i < total_lines - 1) and (not lines[i+1].strip())
        has_chapter_after = (i < total_lines - 2) and lines[i+2] and is_chapter_title_line(lines[i+2])

        # Only center if it's a book title (followed by empty line and chapter)
        is_book_title = (prev_empty and next_empty and has_chapter_after and
                         line.strip() and not re.match(r'^\d+\s+', line))

        if is_book_title:
            # Center book titles with 4-space indent
            clean_line = line.strip()
            # Calculate padding for centering within the remaining width after 4 spaces
            available_width = width - 4
            padding = (available_width - len(clean_line)) // 2
            if padding > 0:
                print(' ' * 4 + ' ' * padding + clean_line)
            else:
                print(' ' * 4 + clean_line)
            continue

        # Check if line is a chapter title
        is_chapter = is_chapter_title_line(line)
        prev_empty_for_chapter = (i == 0) or (i > 0 and not lines[i-1].strip())
        next_empty_for_chapter = (i == total_lines - 1) or (i < total_lines - 1 and not lines[i+1].strip())

        is_chapter_title = (is_chapter and prev_empty_for_chapter and
                            next_empty_for_chapter and line.strip())

        if is_chapter_title:
            # Center chapter titles with 4-space indent
            clean_line = line.strip()
            # Calculate padding for centering within the remaining width after 4 spaces
            available_width = width - 4
            padding = (available_width - len(clean_line)) // 2
            if padding > 0:
                print(' ' * 4 + ' ' * padding + clean_line)
            else:
                print(' ' * 4 + clean_line)
            continue

        # Check if line is an annotation (starts with number but is surrounded by empty lines)
        verse_match = re.match(r'^(\d+)\s+(.*)$', line)
        prev_empty_for_annotation = (i == 0) or (i > 0 and not lines[i-1].strip())
        next_empty_for_annotation = (i == total_lines - 1) or (i < total_lines - 1 and not lines[i+1].strip())

        is_annotation = (verse_match and prev_empty_for_annotation and
                         next_empty_for_annotation and line.strip())

        if is_annotation:
            # Annotations get 4-space indent and full justification (not verse formatting)
            # Use the ENTIRE line including the starting number
            words = line.split()

            if not words:
                print("    " + line)  # 4 spaces
                continue

            # For annotations, available width is reduced by 4 spaces for indent
            available_width = width - 4

            # Build lines manually for justification
            current_line = []
            current_len = 0
            is_first_line = True

            for word in words:
                if current_len + len(word) + len(current_line) <= available_width:
                    current_line.append(word)
                    current_len += len(word)
                else:
                    # Justify and print current line with 4-space indent
                    if len(current_line) > 1:
                        spaces_needed = available_width - current_len
                        gaps = len(current_line) - 1
                        spaces_per_gap = spaces_needed // gaps
                        extra_spaces = spaces_needed % gaps

                        justified = current_line[0]
                        for i in range(1, len(current_line)):
                            spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)
                            justified += ' ' * spaces + current_line[i]

                        if is_first_line:
                            print(f"    {justified}")  # 4 spaces
                            is_first_line = False
                        else:
                            print("    " + justified)  # 4 spaces for continuation lines
                    else:
                        if is_first_line:
                            print(f"    {' '.join(current_line)}")  # 4 spaces
                            is_first_line = False
                        else:
                            print("    " + ' '.join(current_line))  # 4 spaces

                    current_line = [word]
                    current_len = len(word)

            # Print last line (left-aligned with 4-space indent)
            if current_line:
                if is_first_line:
                    print(f"    {' '.join(current_line)}")  # 4 spaces
                else:
                    print("    " + ' '.join(current_line))  # 4 spaces
            continue

        # Check if line starts with a verse number (digit followed by space) - regular verse
        if verse_match and not is_annotation:
            verse_num = verse_match.group(1)
            text_after_verse = verse_match.group(2)
            words = text_after_verse.split()

            if not words:
                print(line)
                continue

            # Add proper spacing based on verse number
            if len(verse_num) == 1:
                # Numbers 1-9: add 2 spaces before
                verse_prefix = "  " + verse_num
            elif len(verse_num) == 2:
                # Numbers 10-99: add 1 space before
                verse_prefix = " " + verse_num
            else:
                # Numbers 100+: no extra space
                verse_prefix = verse_num

            # Calculate available width for the text (minus verse prefix and space)
            available_width = width - len(verse_prefix) - 1

            # Build lines manually for justification
            current_line = []
            current_len = 0
            is_first_line = True

            for word in words:
                if current_len + len(word) + len(current_line) <= available_width:
                    current_line.append(word)
                    current_len += len(word)
                else:
                    # Justify and print current line with verse prefix
                    if len(current_line) > 1:
                        spaces_needed = available_width - current_len
                        gaps = len(current_line) - 1
                        spaces_per_gap = spaces_needed // gaps
                        extra_spaces = spaces_needed % gaps

                        justified = current_line[0]
                        for i in range(1, len(current_line)):
                            spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)
                            justified += ' ' * spaces + current_line[i]

                        if is_first_line:
                            print(f"{verse_prefix} {justified}")
                            is_first_line = False
                        else:
                            # For continuation lines, use spaces equal to verse prefix length + 1
                            print(" " * (len(verse_prefix) + 1) + justified)
                    else:
                        if is_first_line:
                            print(f"{verse_prefix} {' '.join(current_line)}")
                            is_first_line = False
                        else:
                            print(" " * (len(verse_prefix) + 1) + ' '.join(current_line))

                    current_line = [word]
                    current_len = len(word)

            # Print last line
            if current_line:
                if is_first_line:
                    print(f"{verse_prefix} {' '.join(current_line)}")
                else:
                    print(" " * (len(verse_prefix) + 1) + ' '.join(current_line))

        else:
            # Regular line processing (no verse number) - add 4 spaces indent
            words = line.split()
            if not words:
                print("    ")  # 4 spaces for empty lines
                continue

            # For regular text, available width is reduced by 4 spaces for indent
            available_width = width - 4

            # Build lines manually for justification
            current_line = []
            current_len = 0
            is_first_line = True

            for word in words:
                if current_len + len(word) + len(current_line) <= available_width:
                    current_line.append(word)
                    current_len += len(word)
                else:
                    # Justify and print current line with 4-space indent
                    if len(current_line) > 1:
                        spaces_needed = available_width - current_len
                        gaps = len(current_line) - 1
                        spaces_per_gap = spaces_needed // gaps
                        extra_spaces = spaces_needed % gaps

                        justified = current_line[0]
                        for i in range(1, len(current_line)):
                            spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)
                            justified += ' ' * spaces + current_line[i]

                        if is_first_line:
                            print(f"    {justified}")  # 4 spaces
                            is_first_line = False
                        else:
                            print("    " + justified)  # 4 spaces for continuation lines
                    else:
                        if is_first_line:
                            print(f"    {' '.join(current_line)}")  # 4 spaces
                            is_first_line = False
                        else:
                            print("    " + ' '.join(current_line))  # 4 spaces

                    current_line = [word]
                    current_len = len(word)

            # Print last line (left-aligned with 4-space indent)
            if current_line:
                if is_first_line:
                    print(f"    {' '.join(current_line)}")  # 4 spaces
                else:
                    print("    " + ' '.join(current_line))  # 4 spaces

def is_chapter_title_line(line):
    """Check if a line looks like a chapter title"""
    line = line.strip()

    # Don't treat verse lines as chapter titles - verses have text after the number
    if re.match(r'^\d+\s+', line) and len(line.split()) > 2:
        # Check if it's actually a verse with substantial text
        parts = line.split(None, 1)  # Split only on first space
        if len(parts) > 1 and len(parts[1].strip()) > 10:  # If there's substantial text after verse number
            return False

    # Look for patterns like "Book Name Chapter" where chapter is a number
    # This matches: "1 Ездры 1", "Бытие 1", "Genesis 1", "1 Corinthians 1", "1 Тимофею 1"
    patterns = [
        r'^.*\b\d+$',                           # Ends with number (Бытие 1, Genesis 1)
        r'^\d+\s+.*\s+\d+$',                    # Starts and ends with number (1 Ездры 1, 1 Тимофею 1, 1 Corinthians 1)
        r'^.*\s+\d+\s*$',                       # Contains number at end with optional space
        r'^\d+\s+[A-Za-zА-Яа-я]+\s+\d+$',      # Number Word Number (1 Timothy 1, 1 Тимофею 1)
        r'^[A-Za-zА-Яа-я]+\s+\d+$',            # Word Number (Genesis 1, Бытие 1)
    ]

    for pattern in patterns:
        if re.search(pattern, line):
            return True

    # Also check if it's a simple "Book Chapter" pattern with exactly 2-3 words and ends with number
    words = line.split()
    if 2 <= len(words) <= 3:
        # Check if last word is a number
        if words[-1].isdigit():
            return True

    return False


if __name__ == "__main__":
    # If no arguments provided, print help and exit
    if len(sys.argv) == 1:
        print_usage(sys.argv[0])
        sys.exit(0)

    width = 60

    # Handle command line arguments
    if len(sys.argv) > 1:
        # Check if first argument is a width number
        if sys.argv[1].isdigit():
            width = int(sys.argv[1])
            # Read from stdin
            justify_text(sys.stdin, width)
        else:
            # First argument is filename or width
            if len(sys.argv) >= 2:
                if sys.argv[1] in ['-h', '--help', 'help']:
                    print_usage(sys.argv[0])
                    sys.exit(0)
                elif sys.argv[1] == '-':
                    # Read from stdin
                    justify_text(sys.stdin, width)
                else:
                    # Check if second argument is width
                    if len(sys.argv) >= 3 and sys.argv[2].isdigit():
                        width = int(sys.argv[2])
                        # Read from file
                    with open(sys.argv[1], 'r') as f:
                        justify_text(f, width)
