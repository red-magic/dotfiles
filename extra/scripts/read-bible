#!/usr/bin/env python3

import sys
import re
import signal
from typing import TextIO, List, Tuple

signal.signal(signal.SIGPIPE, signal.SIG_DFL)

def print_usage(script_name: str) -> None:
    print(f"Usage: {script_name} [width] <filename>")
    print(f"Options:")
    print(f"  -n, --no-justify  Disable text justification")
    print(f"  -h, --help        Show this help")
    print(f"Examples:")
    print(f"  {script_name} kjv.txt")
    print(f"  {script_name} 80 kjv.txt")
    print(f"  {script_name} -n kjv.txt")

def parse_arguments() -> Tuple[int, str, bool]:
    width = 60
    filename = None
    justify = True

    if len(sys.argv) == 1:
        print_usage(sys.argv[0])
        sys.exit(0)

    for arg in sys.argv[1:]:
        if arg.isdigit():
            width = int(arg)
        elif arg in ['-n', '--no-justify']:
            justify = False
        elif arg in ['-h', '--help', 'help']:
            print_usage(sys.argv[0])
            sys.exit(0)
        else:
            filename = arg

    if not filename:
        print("Error: No filename provided")
        print_usage(sys.argv[0])
        sys.exit(1)

    return width, filename, justify

def is_surrounded_by_empty(lines: List[str], index: int) -> bool:
    prev_empty = index == 0 or not lines[index-1].strip()
    next_empty = index == len(lines) - 1 or not lines[index+1].strip()
    return prev_empty and next_empty

def print_centered_line(line: str, width: int) -> None:
    clean_line = line.strip()
    available_width = width - 4
    padding = max(0, (available_width - len(clean_line)) // 2)
    print(' ' * 4 + ' ' * padding + clean_line)

def format_verse_prefix(verse_num: str) -> str:
    if len(verse_num) == 1:
        return "  " + verse_num
    elif len(verse_num) == 2:
        return " " + verse_num
    else:
        return verse_num

def print_justified_line(words: List[str], available_width: int, prefix: str, is_first: bool) -> None:
    if not words:
        return

    if len(words) > 1:
        text_len = sum(len(word) for word in words)
        spaces_needed = available_width - text_len
        gaps = len(words) - 1
        spaces_per_gap = spaces_needed // gaps
        extra_spaces = spaces_needed % gaps

        justified = words[0]
        for i in range(1, len(words)):
            spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)
            justified += ' ' * spaces + words[i]
    else:
        justified = words[0]

    if is_first:
        print(f"{prefix} {justified}")
    else:
        print(" " * (len(prefix) + 1) + justified)

def process_verse_line(line: str, width: int, justify: bool) -> None:
    verse_match = re.match(r'^(\d+)\s+(.*)$', line)
    if not verse_match:
        print(' ' * 4 + line)
        return

    verse_num = verse_match.group(1)
    text_after_verse = verse_match.group(2)
    words = text_after_verse.split()

    if not words:
        print(line)
        return

    verse_prefix = format_verse_prefix(verse_num)
    available_width = width - len(verse_prefix) - 1

    current_line = []
    current_len = 0
    is_first_line = True

    for word in words:
        if current_len + len(word) + len(current_line) <= available_width:
            current_line.append(word)
            current_len += len(word)
        else:
            if justify:
                print_justified_line(current_line, available_width, verse_prefix, is_first_line)
            else:
                line_text = ' '.join(current_line)
                if is_first_line:
                    print(f"{verse_prefix} {line_text}")
                else:
                    print(" " * (len(verse_prefix) + 1) + line_text)

            current_line = [word]
            current_len = len(word)
            is_first_line = False

    if current_line:
        line_text = ' '.join(current_line)
        if is_first_line:
            print(f"{verse_prefix} {line_text}")
        else:
            print(" " * (len(verse_prefix) + 1) + line_text)

def format_text(file_input: TextIO, width: int = 60, justify: bool = True) -> None:
    lines = [line.rstrip() for line in file_input]

    for i, line in enumerate(lines):
        if not line.strip():
            print()
            continue

        if is_surrounded_by_empty(lines, i):
            print_centered_line(line, width)
            continue

        if re.match(r'^\d+', line):
            process_verse_line(line, width, justify)
        else:
            print(' ' * 4 + line)

def main() -> None:
    width, filename, justify = parse_arguments()

    try:
        with open(filename, 'r', encoding='utf-8') as f:
            format_text(f, width, justify)
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
